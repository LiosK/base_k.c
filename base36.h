#ifndef BASE36_H
#define BASE36_H

#include "base_k.h"

#define BASE36_RADIX (36)

const char BASE36_DIGITS[] = "0123456789abcdefghijklmnopqrstuvwxyz";

/** O(1) map from ASCII code points to digit values. */
const uint8_t BASE36_DECODE_MAP[256] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
    0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
    0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
    0x21, 0x22, 0x23, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff};

#ifdef __cplusplus
extern "C" {
#endif

#define BASE36_128_LEN (25)

/** Encodes a byte array to text. */
void base36_128_encode(const uint8_t *bytes, char *text) {
  uint8_t dst[BASE36_128_LEN];
  int err =
      base_k_convert_radix(dst, bytes, BASE36_RADIX, 256, BASE36_128_LEN, 16);
  assert(err == 0);
  for (int i = 0; i < BASE36_128_LEN; i++) {
    text[i] = BASE36_DIGITS[dst[i]];
  }
  text[BASE36_128_LEN] = '\0';
}

/** Decodes text to a byte array. */
int base36_128_decode(const char *text, uint8_t *bytes) {
  uint8_t src[BASE36_128_LEN];
  const uint8_t *uchars = (const uint8_t *)text;
  for (int i = 0; i < BASE36_128_LEN; i++) {
    uint8_t d = BASE36_DECODE_MAP[uchars[i]];
    if (d >= BASE36_RADIX) {
      return -1; // invalid character
    }
    src[i] = d;
  }
  int err =
      base_k_convert_radix(bytes, src, 256, BASE36_RADIX, 16, BASE36_128_LEN);
  assert(err == 0);
  return 0;
}

#ifdef __cplusplus
} /* extern "C" { */
#endif

#endif /* #ifndef BASE36_H */
